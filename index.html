<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Emoji Rendering System Test</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 1000px;
                margin: 0 auto;
                padding: 20px;
            }

            h1,
            h2,
            h3 {
                color: #333;
            }

            .test-section {
                margin-bottom: 30px;
                padding: 15px;
                border: 1px solid #ddd;
                border-radius: 5px;
            }

            .canvas-container {
                margin: 15px 0;
            }

            canvas {
                border: 1px solid #ccc;
                background-color: #f9f9f9;
            }

            .controls {
                margin: 15px 0;
            }

            .emoji-grid {
                display: grid;
                grid-template-columns: repeat(10, 1fr);
                gap: 10px;
                margin: 15px 0;
            }

            .emoji-item {
                font-size: 24px;
                text-align: center;
                cursor: pointer;
                padding: 5px;
                border-radius: 5px;
            }

            .emoji-item:hover {
                background-color: #f0f0f0;
            }

            .skin-tone-selector {
                display: flex;
                gap: 10px;
                margin: 15px 0;
            }

            .skin-tone-option {
                font-size: 24px;
                cursor: pointer;
                padding: 5px;
                border-radius: 5px;
            }

            .skin-tone-option:hover {
                background-color: #f0f0f0;
            }

            .selected {
                background-color: #e0e0e0;
            }

            .browser-info {
                margin-bottom: 15px;
                padding: 10px;
                background-color: #f5f5f5;
                border-radius: 5px;
            }

            .status {
                padding: 5px 10px;
                border-radius: 3px;
                display: inline-block;
                margin-left: 10px;
            }

            .status.success {
                background-color: #d4edda;
                color: #155724;
            }

            .status.warning {
                background-color: #fff3cd;
                color: #856404;
            }

            .status.error {
                background-color: #f8d7da;
                color: #721c24;
            }
        </style>
    </head>
    <body>
        <h1>Emoji Rendering System Test</h1>

        <div class="browser-info">
            <h3>Browser Compatibility Check</h3>
            <div id="browser-details"></div>
            <div id="emoji-support-status"></div>
        </div>

        <div class="test-section">
            <h2>Basic Emoji Rendering</h2>
            <p>Testing basic emoji rendering on canvas:</p>
            <div class="canvas-container">
                <canvas id="basic-canvas" width="500" height="200"></canvas>
            </div>
        </div>

        <div class="test-section">
            <h2>Emoji Grid System</h2>
            <p>Testing emoji grid rendering:</p>
            <div class="canvas-container">
                <canvas id="grid-canvas" width="500" height="300"></canvas>
            </div>
        </div>

        <div class="test-section">
            <h2>Skin Tone Variants</h2>
            <p>Select an emoji and apply different skin tones:</p>
            <div class="emoji-grid" id="emoji-selector">
                <!-- Emojis that support skin tones will be populated here -->
            </div>

            <div>
                <h3>Selected Emoji:
                    <span id="selected-emoji">üëã</span></h3>
                <div class="skin-tone-selector" id="skin-tone-selector">
                    <!-- Skin tone options will be populated here -->
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="skin-tone-canvas" width="500" height="100"></canvas>
            </div>
        </div>

        <div class="test-section">
            <h2>Emoji Presentation Styles</h2>
            <p>Testing text vs. emoji presentation styles:</p>
            <div class="canvas-container">
                <canvas id="style-canvas" width="500" height="100"></canvas>
            </div>
        </div>

        <div class="test-section">
            <h2>Emoji Animation System</h2>
            <p>Testing emoji animations and transitions:</p>

            <div class="animation-controls">
                <h3>Animation Types</h3>
                <div class="control-buttons">
                    <button id="cycle-animation-btn">Cycle Animation</button>
                    <button id="bounce-animation-btn">Bounce Animation</button>
                    <button id="shake-animation-btn">Shake Animation</button>
                    <button id="typing-animation-btn">Typing Animation</button>
                    <button id="stop-animation-btn">Stop All</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="animation-canvas" width="500" height="200"></canvas>
            </div>

            <div class="animation-controls">
                <h3>Transition Effects</h3>
                <div class="control-buttons">
                    <button id="fade-transition-btn">Fade Transition</button>
                    <button id="scale-transition-btn">Scale Transition</button>
                    <button id="rotate-transition-btn">Rotate Transition</button>
                    <button id="pulse-transition-btn">Pulse Transition</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="transition-canvas" width="500" height="100"></canvas>
            </div>
        </div>

        <script type="module">
            import {createCanvas, createEmojiRenderer} from './src/core/graphics/emojiRenderer.js';
            import {
                SKIN_TONES,
                EMOJI_STYLE,
                applyEmojiSkinTone,
                applyEmojiStyle,
                getAllSkinToneVariations,
                supportsSkinTone,
                detectEmojiSupport,
                EMOJI_CATEGORIES
            } from './src/core/graphics/emojiUtils.js';
            import {createEmojiAnimator, createAnimation, createAnimationFrame, createEmojiTransition} from './src/core/graphics/emojiAnimator.js';

            // Browser compatibility check
            const browserDetailsEl = document.getElementById('browser-details');
            const emojiSupportStatusEl = document.getElementById('emoji-support-status');

            // Display browser information
            const browserInfo = {
                name: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language
            };

            browserDetailsEl.innerHTML = `
      <p><strong>User Agent:</strong> ${browserInfo.name}</p>
      <p><strong>Platform:</strong> ${browserInfo.platform}</p>
      <p><strong>Language:</strong> ${browserInfo.language}</p>
    `;

            // Check emoji support
            const emojiSupported = detectEmojiSupport();
            emojiSupportStatusEl.innerHTML = emojiSupported
                ? '<p><strong>Emoji Support:</strong> <span class="status success">Supported</span></p>'
                : '<p><strong>Emoji Support:</strong> <span class="status error">Limited Support</span></p>';

            // Basic emoji rendering test
            const basicCanvas = document.getElementById('basic-canvas');
            const basicCtx = basicCanvas.getContext('2d');
            const basicRenderer = createEmojiRenderer(basicCtx);

            // Clear canvas with white background
            basicCtx.fillStyle = 'white';
            basicCtx.fillRect(0, 0, basicCanvas.width, basicCanvas.height);

            // Render various emojis at different sizes
            const basicEmojis = [
                'üòÄ',
                'üöÄ',
                'üåà',
                'üéÆ',
                'üçï',
                'üê±',
                'üèÜ',
                'üåç'
            ];
            basicEmojis.forEach((emoji, index) => {
                const x = 60 + (index % 4) * 120;
                const y = 60 + Math.floor(index / 4) * 80;
                const size = 30 + (index % 3) * 10;
                basicRenderer.renderEmoji(emoji, x, y, size);
            });

            // Grid rendering test
            const gridCanvas = document.getElementById('grid-canvas');
            const gridCtx = gridCanvas.getContext('2d');
            const gridRenderer = createEmojiRenderer(gridCtx);

            // Clear canvas with white background
            gridCtx.fillStyle = 'white';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);

            // Create a sample emoji grid (5x5)
            const emojiGrid = [
                [
                    'üå≥', 'üå≥', 'üå≥', 'üå≥', 'üå≥'
                ],
                [
                    'üå≥', 'üè†', 'üõ£Ô∏è', 'üè™', 'üå≥'
                ],
                [
                    'üå≥', 'üõ£Ô∏è', 'üõ£Ô∏è', 'üõ£Ô∏è', 'üå≥'
                ],
                [
                    'üå≥', 'üöó', 'üõ£Ô∏è', 'üö∂', 'üå≥'
                ],
                [
                    'üå≥', 'üå≥', 'üå≥', 'üå≥', 'üå≥'
                ]
            ];

            // Draw grid lines
            gridCtx.strokeStyle = '#ddd';
            const cellSize = 60;
            const gridStartX = 50;
            const gridStartY = 30;

            for (let i = 0; i <= emojiGrid.length; i++) {
                // Horizontal lines
                gridCtx.beginPath();
                gridCtx.moveTo(gridStartX, gridStartY + i * cellSize);
                gridCtx.lineTo(gridStartX + emojiGrid[0].length * cellSize, gridStartY + i * cellSize);
                gridCtx.stroke();

                // Vertical lines
                gridCtx.beginPath();
                gridCtx.moveTo(gridStartX + i * cellSize, gridStartY);
                gridCtx.lineTo(gridStartX + i * cellSize, gridStartY + emojiGrid.length * cellSize);
                gridCtx.stroke();
            }

            // Render the emoji grid
            gridRenderer.renderEmojiGrid(emojiGrid, gridStartX, gridStartY, cellSize, 40);

            // Skin tone test
            const skinToneCanvas = document.getElementById('skin-tone-canvas');
            const skinToneCtx = skinToneCanvas.getContext('2d');
            const skinToneRenderer = createEmojiRenderer(skinToneCtx);

            // Populate emoji selector with emojis that support skin tones
            const emojiSelectorEl = document.getElementById('emoji-selector');
            const skinToneSupportingEmojis = [
                'üëã',
                'üëç',
                'üëé',
                '‚úä',
                'üëä',
                'üëè',
                'üôå',
                'üëÜ',
                'üëá',
                'üôè',
                'üí™',
                'ü§≥',
                'üíÖ',
                'üë®',
                'üë©'
            ];

            skinToneSupportingEmojis.forEach(emoji => {
                const emojiEl = document.createElement('div');
                emojiEl.className = 'emoji-item';
                emojiEl.textContent = emoji;
                emojiEl.addEventListener('click', () => {
                    document
                        .querySelectorAll('.emoji-item')
                        .forEach(el => el.classList.remove('selected'));
                    emojiEl
                        .classList
                        .add('selected');
                    document
                        .getElementById('selected-emoji')
                        .textContent = emoji;
                    updateSkinToneCanvas();
                });
                emojiSelectorEl.appendChild(emojiEl);
            });

            // Populate skin tone selector
            const skinToneSelectorEl = document.getElementById('skin-tone-selector');
            const skinToneOptions = [
                {
                    label: 'Default',
                    value: null
                }, {
                    label: 'üëãüèª',
                    value: SKIN_TONES.LIGHT
                }, {
                    label: 'üëãüèº',
                    value: SKIN_TONES.MEDIUM_LIGHT
                }, {
                    label: 'üëãüèΩ',
                    value: SKIN_TONES.MEDIUM
                }, {
                    label: 'üëãüèæ',
                    value: SKIN_TONES.MEDIUM_DARK
                }, {
                    label: 'üëãüèø',
                    value: SKIN_TONES.DARK
                }
            ];

            let selectedSkinTone = null;

            skinToneOptions.forEach(option => {
                const optionEl = document.createElement('div');
                optionEl.className = 'skin-tone-option';
                optionEl.textContent = option.label;
                optionEl.addEventListener('click', () => {
                    document
                        .querySelectorAll('.skin-tone-option')
                        .forEach(el => el.classList.remove('selected'));
                    optionEl
                        .classList
                        .add('selected');
                    selectedSkinTone = option.value;
                    updateSkinToneCanvas();
                });
                skinToneSelectorEl.appendChild(optionEl);
            });

            // Select first emoji and default skin tone by default
            document
                .querySelector('.emoji-item')
                .classList
                .add('selected');
            document
                .querySelector('.skin-tone-option')
                .classList
                .add('selected');

            function updateSkinToneCanvas() {
                // Clear canvas
                skinToneCtx.fillStyle = 'white';
                skinToneCtx.fillRect(0, 0, skinToneCanvas.width, skinToneCanvas.height);

                const selectedEmoji = document
                    .getElementById('selected-emoji')
                    .textContent;
                const modifiedEmoji = selectedSkinTone
                    ? applyEmojiSkinTone(selectedEmoji, selectedSkinTone)
                    : selectedEmoji;

                // Render the emoji with selected skin tone
                skinToneRenderer.renderEmoji(modifiedEmoji, skinToneCanvas.width / 2, skinToneCanvas.height / 2, 60);
            }

            // Initial render
            updateSkinToneCanvas();

            // Emoji presentation style test
            const styleCanvas = document.getElementById('style-canvas');
            const styleCtx = styleCanvas.getContext('2d');
            const styleRenderer = createEmojiRenderer(styleCtx);

            // Clear canvas
            styleCtx.fillStyle = 'white';
            styleCtx.fillRect(0, 0, styleCanvas.width, styleCanvas.height);

            // Test emojis with different presentation styles
            const testEmojisForStyle = ['‚ù§', '‚òÄ', '‚úÖ', '‚≠ê', '‚òé'];

            testEmojisForStyle.forEach((emoji, index) => {
                const x = 100 + index * 100;
                const y = 30;

                // Text style
                const textStyleEmoji = applyEmojiStyle(emoji, EMOJI_STYLE.TEXT);
                styleRenderer.renderEmoji(textStyleEmoji, x, y, 30);

                // Label
                styleCtx.fillStyle = 'black';
                styleCtx.font = '12px Arial';
                styleCtx.textAlign = 'center';
                styleCtx.fillText('Text Style', x, y + 30);

                // Emoji style
                const emojiStyleEmoji = applyEmojiStyle(emoji, EMOJI_STYLE.EMOJI);
                styleRenderer.renderEmoji(emojiStyleEmoji, x, y + 60, 30);

                // Label
                styleCtx.fillText('Emoji Style', x, y + 90);
            });

            // Animation system test
            const animationCanvas = document.getElementById('animation-canvas');
            const animationCtx = animationCanvas.getContext('2d');
            const animationRenderer = createEmojiRenderer(animationCtx);
            const animator = createEmojiAnimator(animationRenderer);

            // Clear canvas with white background
            animationCtx.fillStyle = 'white';
            animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);

            // Transition canvas
            const transitionCanvas = document.getElementById('transition-canvas');
            const transitionCtx = transitionCanvas.getContext('2d');
            const transitionRenderer = createEmojiRenderer(transitionCtx);
            const transitionAnimator = createEmojiAnimator(transitionRenderer);

            // Clear transition canvas
            transitionCtx.fillStyle = 'white';
            transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

            // Track active animations
            let activeAnimationId = null;
            let activeTransitionId = null;

            // Animation button handlers
            document
                .getElementById('cycle-animation-btn')
                .addEventListener('click', () => {
                    // Stop any existing animation
                    if (activeAnimationId) {
                        animator.stopAnimation(activeAnimationId);
                    }

                    // Clear canvas
                    animationCtx.fillStyle = 'white';
                    animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);

                    // Create a cycle animation with different emojis
                    const emojis = [
                        'üòÄ',
                        'üòÅ',
                        'üòÇ',
                        'ü§£',
                        'üòÉ',
                        'üòÑ',
                        'üòÖ',
                        'üòÜ'
                    ];
                    const cycleAnimation = animator.createEmojiCycleAnimation(emojis, 300, {
                        loop: true,
                        name: 'emoji_cycle'
                    });

                    // Play the animation
                    activeAnimationId = animator.playAnimation(null, cycleAnimation, animationCanvas.width / 2, animationCanvas.height / 2, 60);
                });

            document
                .getElementById('bounce-animation-btn')
                .addEventListener('click', () => {
                    // Stop any existing animation
                    if (activeAnimationId) {
                        animator.stopAnimation(activeAnimationId);
                    }

                    // Clear canvas
                    animationCtx.fillStyle = 'white';
                    animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);

                    // Create a bounce animation
                    const bounceAnimation = animator.createBounceAnimation('üèÄ', 1000, 20, 1.5);

                    // Play the animation
                    activeAnimationId = animator.playAnimation(null, bounceAnimation, animationCanvas.width / 2, animationCanvas.height / 2, 60);
                });

            document
                .getElementById('shake-animation-btn')
                .addEventListener('click', () => {
                    // Stop any existing animation
                    if (activeAnimationId) {
                        animator.stopAnimation(activeAnimationId);
                    }

                    // Clear canvas
                    animationCtx.fillStyle = 'white';
                    animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);

                    // Create a shake animation
                    const shakeAnimation = animator.createShakeAnimation('üò±', 800, 15, 0.3);

                    // Play the animation
                    activeAnimationId = animator.playAnimation(null, shakeAnimation, animationCanvas.width / 2, animationCanvas.height / 2, 60);
                });

            document
                .getElementById('typing-animation-btn')
                .addEventListener('click', () => {
                    // Stop any existing animation
                    if (activeAnimationId) {
                        animator.stopAnimation(activeAnimationId);
                    }

                    // Clear canvas
                    animationCtx.fillStyle = 'white';
                    animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);

                    // Create a typing animation
                    const typingAnimation = animator.createTypingAnimation('üí¨', 1000, 10);

                    // Play the animation
                    activeAnimationId = animator.playAnimation(null, typingAnimation, animationCanvas.width / 2, animationCanvas.height / 2, 60);
                });

            document
                .getElementById('stop-animation-btn')
                .addEventListener('click', () => {
                    // Stop all animations
                    animator.stopAllAnimations();
                    activeAnimationId = null;

                    // Clear canvas
                    animationCtx.fillStyle = 'white';
                    animationCtx.fillRect(0, 0, animationCanvas.width, animationCanvas.height);
                });

            // Transition button handlers
            document
                .getElementById('fade-transition-btn')
                .addEventListener('click', () => {
                    // Stop any existing transition
                    if (activeTransitionId) {
                        transitionAnimator.stopAnimation(activeTransitionId);
                    }

                    // Clear canvas
                    transitionCtx.fillStyle = 'white';
                    transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

                    // Create a fade transition
                    const fadeTransition = createEmojiTransition('üåû', 'üåô', 1500, 'fade', 15);

                    // Play the transition
                    activeTransitionId = transitionAnimator.playAnimation(null, fadeTransition, transitionCanvas.width / 2, transitionCanvas.height / 2, 60);
                });

            document
                .getElementById('scale-transition-btn')
                .addEventListener('click', () => {
                    // Stop any existing transition
                    if (activeTransitionId) {
                        transitionAnimator.stopAnimation(activeTransitionId);
                    }

                    // Clear canvas
                    transitionCtx.fillStyle = 'white';
                    transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

                    // Create a scale transition
                    const scaleTransition = createEmojiTransition('üê£', 'üê•', 1500, 'scale', 15);

                    // Play the transition
                    activeTransitionId = transitionAnimator.playAnimation(null, scaleTransition, transitionCanvas.width / 2, transitionCanvas.height / 2, 60);
                });

            document
                .getElementById('rotate-transition-btn')
                .addEventListener('click', () => {
                    // Stop any existing transition
                    if (activeTransitionId) {
                        transitionAnimator.stopAnimation(activeTransitionId);
                    }

                    // Clear canvas
                    transitionCtx.fillStyle = 'white';
                    transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

                    // Create a rotate transition
                    const rotateTransition = createEmojiTransition('üçÉ', 'üçÇ', 1500, 'rotate', 15);

                    // Play the transition
                    activeTransitionId = transitionAnimator.playAnimation(null, rotateTransition, transitionCanvas.width / 2, transitionCanvas.height / 2, 60);
                });

            document
                .getElementById('pulse-transition-btn')
                .addEventListener('click', () => {
                    // Stop any existing transition
                    if (activeTransitionId) {
                        transitionAnimator.stopAnimation(activeTransitionId);
                    }

                    // Clear canvas
                    transitionCtx.fillStyle = 'white';
                    transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

                    // Create a pulse transition
                    const pulseTransition = createEmojiTransition('‚ù§Ô∏è', 'üíì', 1500, 'pulse', 15);

                    // Play the transition
                    activeTransitionId = transitionAnimator.playAnimation(null, pulseTransition, transitionCanvas.width / 2, transitionCanvas.height / 2, 60);
                });

            // Add some CSS for the animation controls
            const style = document.createElement('style');
            style.textContent = `
                .animation-controls {
                    margin: 15px 0;
                }
                .control-buttons {
                    display: flex;
                    gap: 10px;
                    flex-wrap: wrap;
                    margin-bottom: 15px;
                }
                .control-buttons button {
                    padding: 8px 12px;
                    background-color: #f0f0f0;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    cursor: pointer;
                }
                .control-buttons button:hover {
                    background-color: #e0e0e0;
                }
            `;
            document
                .head
                .appendChild(style);
        </script>
    </body>
</html>
